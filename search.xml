<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>QT5基础</title>
    <url>/2024/01/24/QT5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="QT5基础"><a href="#QT5基础" class="headerlink" title="QT5基础"></a>QT5基础</h1><h2 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h2><h3 id="分割窗口类QSplitter"><a href="#分割窗口类QSplitter" class="headerlink" title="分割窗口类QSplitter"></a>分割窗口类QSplitter</h3><p>QSplitter* splitterMain &#x3D; new QSPlitter(QT::Horizontal,0)；&#x2F;&#x2F;定义主分割窗口。</p>
<p>QTextEdit *textLeft &#x3D;new QTextEdit(QObject::tr(“Left Widget”), splitterMain);&#x2F;&#x2F;新建一个QTextedit类对象，将其插入主分隔窗口中。</p>
<p>textLeft-&gt;setAlignment(Qt::AlignCenter);&#x2F;&#x2F;设置文字位置，此为文字水平且竖直居中。常用对齐方式有以下几种：</p>
<ul>
<li>Qt::AlignLeft: 左对齐。</li>
<li>Qt::AlignRight: 右对齐。</li>
<li>Qt::AlignCenter:文字居中（Qt::AlignHCenter水平居中，Qt::AlignVcenter数值居中）。</li>
<li>QT::AlginUp文字与顶部对齐。</li>
<li>Qt::AlignBottom文字于底部对齐。</li>
</ul>
<p>QSplitter* splitterRight &#x3D;new QSplitter(Qt::Vertical,splitterMain);</p>
<p>splitterRight-&gt;setOpaqueResize(false);<br>QTextEdit* textUp&#x3D;new QTextEdit(QObject::tr(“TopWidget”),splitterRight);<br>textUp-&gt;setAlignment(Qt::AlignCenter);<br>QTextEdit* textBottom &#x3D;new QTextEdit(QObject::tr(“Bottom Widget”), splitterRight);<br>textBottom-&gt;setAlignment(Qt::AlignCenter);<br>splitterMain-&gt;setStretchFactor(1,1);&#x2F;&#x2F;它的第1个参数用来指定设置的控件序号，控件序号按插入的先后次序从0起依次编号；第2个参数为大于0的值，表示此控件为可伸缩控件。此设置为使第一个插入的左部分在窗口拉伸时宽度保持不变，右部分序号为1，宽度正常变化。	</p>
<h3 id="停靠窗口QDockWidget类"><a href="#停靠窗口QDockWidget类" class="headerlink" title="停靠窗口QDockWidget类"></a>停靠窗口QDockWidget类</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">setWindowTitle(tr(<span class="string">&quot;DockWindows&quot;</span>));<span class="comment">//设置主窗口的标题栏文字</span></span><br><span class="line">QTextEdit* te = <span class="keyword">new</span> QTextEdit(<span class="keyword">this</span>);<span class="comment">//定义一个QTextEdit对象作为主窗口</span></span><br><span class="line">te-&gt;setText(tr(<span class="string">&quot;Main Window&quot;</span>));</span><br><span class="line">te-&gt;setAlignment(<span class="attribute">Qt</span>::AlignLeft);</span><br><span class="line">setCentralWidget(te);<span class="comment">//将此编辑框设为主窗口的中央窗体</span></span><br><span class="line"><span class="comment">//停靠窗口1</span></span><br><span class="line">QDockWidget *dock=<span class="keyword">new</span> QDockWidget(tr(<span class="string">&quot;DockWindow1&quot;</span>),<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//可移动</span></span><br><span class="line">dock-&gt;setFeatures(<span class="attribute">QDockWidget</span>::DockWidgetMovable);</span><br><span class="line">dock&gt;setAllowedAreas(<span class="attribute">Qt</span>::LeftDockWidgetArea|<span class="attribute">Qt</span>::RightDockWidgetArea);<span class="comment">//设置可停靠位置为左边或右边										QTextEdit *te1 =new QTextEdit();</span></span><br><span class="line">te1-&gt;setText(tr(<span class="string">&quot;Window1,The dock widget can be moved between docks by the user&quot;</span> <span class="string">&quot;&quot;</span>));</span><br><span class="line">dock-&gt;setWidget(te1);<span class="comment">//dock中加入编辑器te1</span></span><br><span class="line">addDockWidget(<span class="attribute">Qt</span>::LeftDockWidgetArea,dock);<span class="comment">//初始位置为左</span></span><br><span class="line"><span class="comment">//停靠窗口2</span></span><br><span class="line">dock=<span class="keyword">new</span> QDockWidget(tr(<span class="string">&quot;DockWindow2&quot;</span>),<span class="keyword">this</span>);</span><br><span class="line">dock&gt;setFeatures(<span class="attribute">QDockWidget</span>::DockWidgetClosable|<span class="attribute">QDockWidget</span>::DockWidgetFloatable);<span class="comment">//可关闭、可浮动</span></span><br><span class="line">QTextEdit *te2 =<span class="keyword">new</span> QTextEdit();</span><br><span class="line">te2-&gt;setText(tr(<span class="string">&quot;Window2,The dock widget can be detached from the main window,&quot;</span><span class="string">&quot;and floated as an independent window, and can be closed&quot;</span>));</span><br><span class="line">dock-&gt;setWidget(te2);</span><br><span class="line">addDockWidget(<span class="attribute">Qt</span>::RightDockWidgetArea,dock);<span class="comment">//初始位置为右</span></span><br><span class="line"><span class="comment">//停靠窗口3</span></span><br><span class="line">dock=<span class="keyword">new</span> QDockWidget(tr(<span class="string">&quot;DockWindow3&quot;</span>),<span class="keyword">this</span>);</span><br><span class="line">dock-&gt;setFeatures(<span class="attribute">QDockWidget</span>::AllDockWidgetFeatures);   <span class="comment">//全部特性</span></span><br><span class="line">QTextEdit *te3 =<span class="keyword">new</span> QTextEdit();</span><br><span class="line">te3-&gt;setText(tr(<span class="string">&quot;Window3,The dock widget can be closed, moved, and floated&quot;</span>));</span><br><span class="line">dock-&gt;setWidget(te3);</span><br><span class="line">addDockWidget(<span class="attribute">Qt</span>::TopDockWidgetArea,dock);<span class="comment">//初始位置为上</span></span><br></pre></td></tr></table></figure>

<img src="/2024/01/24/QT5%E5%9F%BA%E7%A1%80/1.png" class="">

<h3 id="堆帐窗体QStackedWidget类"><a href="#堆帐窗体QStackedWidget类" class="headerlink" title="堆帐窗体QStackedWidget类"></a>堆帐窗体QStackedWidget类</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">setWindowTitle(tr(<span class="string">&quot;StackedWidget&quot;</span>));</span><br><span class="line">   <span class="built_in">list</span> =<span class="keyword">new</span> QListWidget(<span class="keyword">this</span>);	<span class="comment">//新建一个QListWidget控件对象</span></span><br><span class="line">   <span class="comment">//在新建的QListWidget控件中插入三个条目，作为选择项</span></span><br><span class="line">   <span class="built_in">list</span>-&gt;insertItem(<span class="number">0</span>,tr(<span class="string">&quot;Window1&quot;</span>));</span><br><span class="line">   <span class="built_in">list</span>-&gt;insertItem(<span class="number">1</span>,tr(<span class="string">&quot;Window2&quot;</span>));</span><br><span class="line">   <span class="built_in">list</span>-&gt;insertItem(<span class="number">2</span>,tr(<span class="string">&quot;Window3&quot;</span>));</span><br><span class="line">   <span class="comment">//创建三个QLabel标签控件对象，作为堆栈窗口需要显示的三层窗体</span></span><br><span class="line">   label1 =<span class="keyword">new</span> QLabel(tr(<span class="string">&quot;WindowTest1&quot;</span>));</span><br><span class="line">   label2 =<span class="keyword">new</span> QLabel(tr(<span class="string">&quot;WindowTest2&quot;</span>));</span><br><span class="line">   label3 =<span class="keyword">new</span> QLabel(tr(<span class="string">&quot;WindowTest3&quot;</span>));</span><br><span class="line">   stack =<span class="keyword">new</span> QStackedWidget(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//新建一个QStackedWidget堆栈窗体对象</span></span><br><span class="line">   <span class="comment">//将创建的三个QLabel标签控件依次插入堆栈窗体中</span></span><br><span class="line">   stack-&gt;addWidget(label1);</span><br><span class="line">   stack-&gt;addWidget(label2);</span><br><span class="line">   stack-&gt;addWidget(label3);</span><br><span class="line">   QHBoxLayout *mainLayout =<span class="keyword">new</span> QHBoxLayout(<span class="keyword">this</span>);</span><br><span class="line">                                   <span class="comment">//对整个对话框进行布局</span></span><br><span class="line">   mainLayout-&gt;setMargin(<span class="number">5</span>);		<span class="comment">//设定对话框（或窗体）的边距为5</span></span><br><span class="line">   mainLayout-&gt;setSpacing(<span class="number">5</span>);		<span class="comment">//设定各个控件之间的间距为5</span></span><br><span class="line">   mainLayout-&gt;addWidget(<span class="built_in">list</span>);</span><br><span class="line">   mainLayout-&gt;addWidget(stack,<span class="number">0</span>,<span class="attribute">Qt</span>::AlignHCenter);</span><br><span class="line">   mainLayout-&gt;setStretchFactor(<span class="built_in">list</span>,<span class="number">1</span>);		<span class="comment">//(a)</span></span><br><span class="line">   mainLayout-&gt;setStretchFactor(stack,<span class="number">3</span>); 			</span><br><span class="line">   	connect(<span class="built_in">list</span>,SIGNAL(currentRowChanged(<span class="built_in">int</span>)),stack,SLOT(setCurrentIndex(<span class="built_in">int</span>)));<span class="comment">//connect(list,SIGNAL(currentRowChanged(int)),stack,SLOT(setCurrentlndex(int))): 将QListWidget的currentRowChanged()信号与堆栈窗体的setCurrentlndex()槽函数连接起来，实现按选择显示窗体。此处的堆栈窗体index按插入的顺序从0起依次排序，与QListWidget的排序一致。</span></span><br></pre></td></tr></table></figure>

<img src="/2024/01/24/QT5%E5%9F%BA%E7%A1%80/2.png" class="">
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>qt基础</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量机制（PV操作）</title>
    <url>/2023/04/30/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%EF%BC%88PV%E6%93%8D%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<p>信号量：<strong>一个信号量对应一种资源</strong>，信号量其实就是一个变量(可以是一个整数,也可以是更复杂的记录型变量),可以用一个信号量来<strong>表示系统中某种资源的数量。</strong>P就是wait操作，等待资源，V就是++操作，释放资源。<br>用户可通过PV操作来实现进程互斥与进程同步。而对于有些书中也使用down和up分别代替PV更好理解，例如用信号量解决生产者和消费者问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100 <span class="comment">//缓冲区中的槽数目</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore; <span class="comment">//信号量是一种特殊的整形数据</span></span><br><span class="line">semaphore mutex= <span class="number">1</span>;  <span class="comment">/*控制对临界区的访问*/</span></span><br><span class="line">semaphore empty = N;  <span class="comment">/*计数缓冲区的空槽数目*/</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">/*计数缓冲区的满槽数目*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;         <span class="comment">/*TRUE是常量1*/</span></span><br><span class="line">item =produce_item();<span class="comment">/*产生放在缓冲区中的一些数据*/</span></span><br><span class="line">down(&amp;empty);        <span class="comment">/*将空槽数目减1*/</span></span><br><span class="line">down(&amp;mutex);        <span class="comment">/*进入临界区*/</span></span><br><span class="line">insert_item(item);   <span class="comment">/*将新数据项放到缓冲区中*/</span></span><br><span class="line">up(&amp;mutex);          <span class="comment">/*离开临界区*/</span></span><br><span class="line">up(&amp;full);           <span class="comment">/*将满槽的数目加1*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;        <span class="comment">/*无限循环*/</span></span><br><span class="line">down(&amp;full);        <span class="comment">/*将满槽数目减1*/</span></span><br><span class="line">down(&amp;mutex);       <span class="comment">/*进入临界区*/</span></span><br><span class="line">item = remove_item();<span class="comment">/*从缓冲区中取出数据项*/</span></span><br><span class="line">up(&amp;mutex);         <span class="comment">/*离开临界区*/</span></span><br><span class="line">up(&amp;empty):         <span class="comment">/*将空槽数目加1*/</span></span><br><span class="line">consume <span class="title function_">item</span><span class="params">(item)</span>; <span class="comment">/*处理数据项*/</span> </span><br><span class="line">     &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>对于PV操作有如下例题：</p>
<p>1.三个进程P1、P2、P3互斥使用一个包含N（N&gt;0）个单元的缓冲区。P1每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义的信号量的含义。要求用伪代码描述。</p>
<p><strong>定义信号量S1控制P1与P2之间的同步；S2控制P1与P3之间的同步；empty控制生产者与消费者 之间的同步；mutex控制进程间互斥使用缓冲区。程序如下：</strong><br><strong>Var S1&#x3D;0, S2&#x3D;0, empty&#x3D;N, mutex&#x3D;1;</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1:begin                           </span><br><span class="line">x=produce();</span><br><span class="line">P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">Put();</span><br><span class="line">V(mutex);</span><br><span class="line">If x%2==0</span><br><span class="line">V(S2);</span><br><span class="line">else</span><br><span class="line">V(S1);</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">P2:begin                           </span><br><span class="line">P(S1);</span><br><span class="line">P(mutex);</span><br><span class="line">getodd();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">countodd();</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">P3:begin                           </span><br><span class="line">P(S2);</span><br><span class="line">P(mutex);</span><br><span class="line">geteven();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">countodd();</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>


<p>2.某工厂有两个生产车间和一个装配车间,两个生产车间分别生产A、B两种零件,装配车间的任务是把A、B两种零件装配成产品。两个生产车间每生产一个零件后都要分别把它们送到装配车间的货架F1、F2上,F1存放零件A,F2存放零件B,F1与F2的容量均为可以存放10个零件。装配工人每次从货架上取一个A零件和一个B零件,然后组装成产品。请用:(1) 信号量和P、V操作</p>
<p>采用信号量和P、V操作(2) 管程,进行正确的管理。</p>
<p>（1）<strong>semaphore mutex, empty1, empty2, full1, full2;</strong></p>
<p><strong>mutex&#x3D;1; &#x2F;&#x2F;互斥信号量,用于互斥使用货架</strong></p>
<p><strong>empty1&#x3D;10; &#x2F;&#x2F;同步信号量,表示货架F1可容纳的零件数</strong></p>
<p><strong>empty2&#x3D;10; &#x2F;&#x2F;同步信号量,表示货架F2可容纳的零件数</strong></p>
<p><strong>full1&#x3D;0; &#x2F;&#x2F;同步信号量,表示货架F1已放的零件数</strong></p>
<p><strong>full2&#x3D;0; &#x2F;&#x2F;同步信号量,表示货架F1已放的零件数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">parbegin</span><br><span class="line">process <span class="title function_">workerAi</span> <span class="params">( )</span> <span class="comment">//第一个生产车间的工人进程,i=1, 2, ... , n</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">生产一个零件A;</span><br><span class="line">P(empty1); <span class="comment">//测试货架F1是否可放零件A</span></span><br><span class="line">P(mutex);</span><br><span class="line">将一个零件A放到货架F1上;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">workerBj</span> <span class="params">( )</span> <span class="comment">//第二个生产车间的工人进程,j=1, 2, ... , m</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">生产一个零件B;</span><br><span class="line">P(empty2); <span class="comment">//测试货架F2是否可放零件B</span></span><br><span class="line">P(mutex);</span><br><span class="line">将一个零件B放到货架F2上</span><br><span class="line">V(mutex);</span><br><span class="line">V(full2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">workerCi</span> <span class="params">( )</span> <span class="comment">//装配车间的工人进程,i=1, 2, ... , k</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">P(full1); <span class="comment">//测试货架F1是否可放零件A</span></span><br><span class="line">P(mutex);</span><br><span class="line">从货架F1上取一个零件A</span><br><span class="line"><span class="title function_">V</span><span class="params">(mutex)</span>;</span><br><span class="line">V(empty);</span><br><span class="line">P(full2);</span><br><span class="line">P(mutex);</span><br><span class="line">从货架F2上取一个零件B</span><br><span class="line"><span class="title function_">V</span><span class="params">(mutex)</span>;</span><br><span class="line">V(empty);</span><br><span class="line">用零件A、B组装成一个产品;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">parend</span><br></pre></td></tr></table></figure>


<p>（2）管程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type PC=monitor</span><br><span class="line">var countA, countB : integer;</span><br><span class="line">CA, CB, CCA, CCB : condition;</span><br><span class="line">procedure putA( ) //往货架F1上放一个零件A</span><br><span class="line">begin</span><br><span class="line">if countA=10 then CA.wait;</span><br><span class="line">将一个零件A放到货架F1上;</span><br><span class="line">countA := countA+1;</span><br><span class="line">if CCA.queue then CCA.signal;</span><br><span class="line">end</span><br><span class="line">procedure putB( ) //往货架F2上放一个零件B</span><br><span class="line">begin</span><br><span class="line">if countB=10 then CB.wait;</span><br><span class="line">将一个零件B放到货架F2上;</span><br><span class="line">countB := countBA+1;</span><br><span class="line">if CCB.queue then CCB.signal;</span><br><span class="line">end</span><br><span class="line">procedure getA( ) //从货架F1上取一个零件A</span><br><span class="line">begin</span><br><span class="line">if countA=0 then CCA.wait;</span><br><span class="line">从货架F1上取一个零件A</span><br><span class="line">countA := countA-1;</span><br><span class="line">if CA.queue then CA.signal;</span><br><span class="line">end</span><br><span class="line">procedure getB( ) //从货架F2上取一个零件B</span><br><span class="line">begin</span><br><span class="line">if countB=0 then CCB.wait;</span><br><span class="line">从货架F2上取一个零件B</span><br><span class="line">countB := countB-1;</span><br><span class="line">if CB.queue then CB.signal;</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">countA := 0; countB := 0;</span><br><span class="line">end</span><br><span class="line">采用上述管程时,本问题的算法可描述如下:</span><br><span class="line">parbegin</span><br><span class="line">process workerAi ( ) //第一个生产车间的工人进程,i=1, 2, ... , n</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">生产一个零件A;</span><br><span class="line">PC.putA( ); //将一个零件A放到货架F1上</span><br><span class="line">until false</span><br><span class="line">end</span><br><span class="line">process workerBj ( ) //第二个生产车间的工人进程,j=1, 2, ... , m</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">生产一个零件B;</span><br><span class="line">PC.putB( ); //将一个零件B放到货架F2上</span><br><span class="line">until false</span><br><span class="line">end</span><br><span class="line">process workerCi ( ) //装配车间的工人进程,i=1, 2, ... , k</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">PC.getA( ); //从货架F1上取一个零件A</span><br><span class="line">PC.getB( ); //从货架F2上取一个零件B</span><br><span class="line">用零件A、B组装成一个产品;</span><br><span class="line">until false</span><br><span class="line">end</span><br><span class="line">parend</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>PV操作</tag>
      </tags>
  </entry>
  <entry>
    <title>TinyWebserver</title>
    <url>/2023/12/21/TinyWebserver/</url>
    <content><![CDATA[<h1 id="TineyWebserver"><a href="#TineyWebserver" class="headerlink" title="TineyWebserver"></a>TineyWebserver</h1><h2 id="服务器基本流程"><a href="#服务器基本流程" class="headerlink" title="服务器基本流程"></a>服务器基本流程</h2><p>大体流程：通过epoll技术来进行网络通信，运用线程池技术创建线程来管理对http数据的处理，同时创建数据库连接池，加入日志队列，定时器类。</p>
<h2 id="lock类"><a href="#lock类" class="headerlink" title="lock类"></a>lock类</h2><p>对线程同步机制封装类。多线程同步，确保任一时刻只有一个线程能进入关键代码段。</p>
<p>总共有三个class，分别为sem,locker,cond</p>
<h5 id="1、sem类（信号量）"><a href="#1、sem类（信号量）" class="headerlink" title="1、sem类（信号量）"></a>1、sem类（信号量）</h5><p>sem类是一个信号量封装类。信号量是一种同步机制，用于控制多个线程之间的访问顺序。通常情况下，当多个线程需要共享一个资源时，需要使用信号量来确保每个线程按照一定的顺序访问该资源，从而避免出现竞争条件和数据不一致等问题</p>
<p>其中构建函数有两个sem()、sem(int num)，他们的区别是是否给sem_init提供信号量初始值（value）</p>
<p>sem_init是一个用于初始化信号量的函数，它有三个参数，分别是：</p>
<ol>
<li>sem：指向要初始化的信号量的指针。</li>
<li>pshared：指定信号量是在进程间共享还是在线程间共享的标志。如果pshared为0，则表示信号量将在同一进程内的线程之间共享；如果pshared为非0值，则表示信号量可以在多个进程之间共享。</li>
<li>value：指定信号量的初始值。</li>
</ol>
<h5 id="2、locker类（互斥锁）"><a href="#2、locker类（互斥锁）" class="headerlink" title="2、locker类（互斥锁）"></a>2、locker类（互斥锁）</h5><p>这个类是一个简单的互斥锁封装，用于在多线程编程中保护共享资源。它使用 POSIX 线程库提供的 <code>pthread_mutex_t</code> 类型和相关函数来实现。</p>
<p>在多线程程序中，使用互斥锁可以避免多个线程同时访问共享资源而导致的数据竞争问题。这里的 lock() 和 unlock() 方法就是为了控制对共享资源的访问，只有获得了互斥锁的线程才能访问共享资源，其他线程则必须等待锁被释放才能获取它。</p>
<h5 id="3、cond类（条件变量）"><a href="#3、cond类（条件变量）" class="headerlink" title="3、cond类（条件变量）"></a>3、cond类（条件变量）</h5><p>这个类使用 POSIX 线程库提供的条件变量来实现线程同步。</p>
<p>在使用条件变量时需要与互斥锁搭配使用，以避免竞态条件的发生。因此，wait 函数和 timewait 函数的参数中传入了一个互斥锁指针，表示等待前需要先加锁，等待结束后再解锁。同时，在每个成员函数中都有注释掉的 mutex 加锁和解锁操作，这是因为加锁和解锁的逻辑应该放在调用 cond 类的外部实现，而不应该在 cond 类的内部实现中。</p>
<h2 id="http类"><a href="#http类" class="headerlink" title="http类"></a>http类</h2><h5 id="状态机的使用"><a href="#状态机的使用" class="headerlink" title="状态机的使用"></a><strong>状态机的使用</strong></h5><p>有限状态机是一种抽象的理论模型，使用选择语句来实现。模型要求代码存在 n 个状态，使用当前状态 <code>cur_state</code> 来进行标记，每次处理完任务后都对其进行更改以实现状态跳转，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>()&#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span>(cur_State != type_C)&#123;</span><br><span class="line">        Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">        <span class="keyword">switch</span>() &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                <span class="built_in">process_pkg_state_A</span>(_pack);</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_pkg_state_B</span>(_pack);</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用主从状态机封装了http连接类。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/65c7c1b67158e62e7d7c3ed8b698633e.jpeg" alt="img"></p>
<p>主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头，当前正在分析请求体（请求正文）。从状态机的三种可能状态，即表示行的读取状态，分别表示：读取到一个完整的行，读取到的行出错，行数据尚且不完整。</p>
<h5 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h5><ol>
<li><p>read_once()循环读取客户数据（相关http请求数据），直到无数据可读或对方关闭连接。</p>
</li>
<li><p>prase_line()是从状态机，用于分析出一行内容的状态，返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN。</p>
</li>
<li><p>pare_request_line(char *text)用于解析http请求行，获得请求方法，目标url及http版本号。</p>
</li>
<li><p>parse_headers(char *text)用于解析http请求的头部信息。</p>
</li>
<li><p>parse_content(char *text)用于判断http请求是否被完整读入。</p>
</li>
<li><p>process_read()用于处理客户端发送的HTTP请求，包括解析请求行、请求头、请求体等，并根据请求内容返回不同的响应状态码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK; <span class="comment">// 表示当前解析出来的行状态</span></span><br><span class="line">    HTTP_CODE ret = NO_REQUEST; <span class="comment">// 表示当前解析出来的方法执行结果</span></span><br><span class="line">    <span class="type">char</span> *text = <span class="number">0</span>; <span class="comment">// 定义一个指向当前读取行缓冲区的指针text初始化为0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//进入while循环，不断地从socket中读取数据，并对其进行解析和处理</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))&#123;</span><br><span class="line">        <span class="comment">// 读取一行数据并保存到text变量中</span></span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line">        <span class="comment">// 设置m_start_line变量为当前已经解析过的字符数（即上一次解析完的位置）</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="comment">// 输出读取到的数据内容</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">        <span class="comment">// 根据m_check_state的不同值，调用相应的函数对当前行数据进行解析和处理</span></span><br><span class="line">        <span class="keyword">switch</span> (m_check_state)&#123;</span><br><span class="line">        <span class="comment">// 解析请求行</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:&#123;</span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析请求头</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:&#123;</span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="comment">// 如果解析请求头部发现请求方法是GET，则直接跳转到do_request()函数进行响应处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析请求体</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:&#123;</span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            <span class="comment">// 如果发现已经读取完整个请求体，则将line_status设置为LINE_OPEN，以便下一轮循环继续读取下一个请求</span></span><br><span class="line">            line_status = LINE_OPEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 NO_REQUEST 状态码，表示HTTP请求未被完整读入</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>process()根据读取到的数据进行处理并返回对应的 HTTP_CODE 枚举值，该函数完成了对客户端请求的处理和响应的发送，并通过 epoll 实现了高效的事件驱动模型，提高了服务器的吞吐量和性能.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用process_read()函数，从客户端socket中读取数据并解析出HTTP请求信息</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="comment">// 当前没有接收到完整的请求数据，函数直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)&#123;</span><br><span class="line">        <span class="comment">// 将客户端socket加入epoll监听列表，等待下一次可读事件触发</span></span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果返回值不为NO_REQUEST，则表示已经成功解析出HTTP请求信息，并准备好回复客户端</span></span><br><span class="line">    <span class="comment">// 调用process_write()函数进行响应报文的构建和发送，并将返回值赋给write_ret变量</span></span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);</span><br><span class="line">    <span class="comment">// 如果process_write()函数返回false，则说明响应发送失败</span></span><br><span class="line">    <span class="keyword">if</span> (!write_ret)&#123;</span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        <span class="built_in">close_conn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将客户端socket加入epoll监听列表，并等待下一次可写事件触发，以继续发送响应数据</span></span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h2 id="日志队列"><a href="#日志队列" class="headerlink" title="日志队列"></a>日志队列</h2><h2 id="webserver类"><a href="#webserver类" class="headerlink" title="webserver类"></a>webserver类</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2023/05/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的启动</title>
    <url>/2023/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>CS：代码段寄存器 IP：指令指针寄存器</p>
<p>(1)X86PC刚开机CPU为实模式（CS：PC(CS左移四位+IP)，得到物理地址，其中四位是二进制四位）</p>
<p>(2)开机时：S&#x3D;0XFFFF；IP&#x3D;0X0000</p>
<p>(3)寻址：0XFFFF0(ROM BIOS 映射区)</p>
<p>(4)检查RAM，键盘，显示器，软硬磁盘</p>
<p>(5)将磁盘0磁道0扇区读入0X7c00处(0磁道0扇区为引导扇区，一个扇区512个字节)</p>
<p>(6)设置CS&#x3D;0X07c0,IP&#x3D;0X0000</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统的启动</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2023/05/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="文件系统的基本组成"><a href="#文件系统的基本组成" class="headerlink" title="文件系统的基本组成"></a>文件系统的基本组成</h3><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>i节点（index node）和目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li><p>索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</p>
</li>
<li><p>目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</p>
<p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>
<p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件</p>
</li>
</ul>
<h3 id="i节点和文件头"><a href="#i节点和文件头" class="headerlink" title="i节点和文件头"></a>i节点和文件头</h3><p><strong>i节点</strong>是文件系统用于存储文件相关元数据的数据结构，包括文件物理位置、大小、类型、权限等信息。在文件创建和写入时，i节点中的数据需要被同时更新或修改。这些数据通常不是自动生成的，而是由相应的文件系统管理程序或操作系统内核进行设置和更新的。<br>具体来说，当用户创建一个新的文件时，文件系统会为它分配一些物理空间并记录它的物理位置信息，然后将这些信息记录到相应的i节点中。在文件的写入操作时，文件系统会根据操作系统或者文件系统设置的i节点内存储相关信息，动态地更新i节点的内容，记录文件的最新物理地址和文件大小信息。<br>需要注意的是，不同的文件系统可能会有不同的i节点格式和不同的元数据信息，因此i节点中存储的信息内容可能会有所差异。但是，无论是哪种文件系统，i节点中的数据都是文件系统管理程序或操作系统内核动态更新的，以便记录和管理文件的相关信息。</p>
<p><strong>文件头</strong>是文件系统用于存储文件相关基本信息的数据结构，通常存储在文件的开头处，并且在文件创建时就会被创建和写入。这些基本信息包括文件的类型、大小、创建时间、修改时间、访问权限等。文件头通常不是自动生成的，而是由<strong>应用程序或操作系统内核</strong>根据特定的规则和用户给定的属性来设置和填充的。<br>具体来说，当用户需要创建一个新文件时，可以通过各种应<strong>用程序或者操作系统内置命令来创建</strong>，并在创建文件时指定一些必要的基本信息，例如文件的类型、大小、文件名、访问权限等。这些基本属性信息将会被写入文件头中，以便应用程序和操作系统在访问和管理文件时能够快速读取基本信息。<br>文件头的格式和元数据信息可能会因不同的操作系统、文件系统或文件类型而异，但是它们的基本目的是相同的，即为文件存储提供一些基本元数据信息，以便应用程序和操作系统可以更好地访问、修改和管理文件。<br>总之，文件头不是自动生成的，而是由应用程序或操作系统内核根据规则和用户给定的属性进行设置和填充，以提供文件的基本元数据信息。</p>
<p><strong>若使用连续分配存储文件，i节点要记录第一块的磁盘位置和文件的块数且文件头可以不指定「起始块的位置」和「长度」吗？</strong></p>
<p>不太可能。</p>
<p>在使用连续分配方式存储文件时，i 节点需要记录第一块的磁盘位置和文件的块数，这是必要的信息，因为这些信息描述了文件的<strong>物理布局</strong>，即文件存储在哪些磁盘块中以及磁盘块的数量和顺序。操作系统需要这些信息才能正确地读取和管理文件。</p>
<p>相比之下，<strong>文件头中存储起始块的位置和长度的信息可以看作是一种优化，它可以加速文件访问和管理的过程</strong>。但是，即使文件头中没有这些信息，操作系统仍然可以通过 i 节点中的信息找到文件的起始块和长度。因此，理论上可以不在文件头中指定起始块的位置和长度，而仅在 i 节点中记录第一块的磁盘位置和文件的块数。</p>
<p>然而，在实际实现中，将文件头中存储起始块的位置和长度的信息和 i 节点中存储第一块的磁盘位置和文件的块数的信息分开记录能够更好地组织文件系统的数据结构，使其更加高效。因此，在使用连续分配方式存储文件时，通常会同时在文件头和 i 节点中记录文件的重要信息，以便实现对文件的高效访问和管理。</p>
<h3 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h3><p>1.连续分配</p>
<p>连续磁盘空间存放方式顾名思义，<strong>文件存放在磁盘「连续的」物理空间中</strong>。</p>
<p>优势：1.实现简单，记录每个文件用到的磁盘块简化为只需要记住连个数字即可：第一块的磁盘地址和文件的块数 2.读操作性能好，单个草做就可以从磁盘上读出整个文件。只需要一次寻找。之后不再需要寻道和旋转延迟。</p>
<p>缺点：1.磁盘空间碎片 2.文件长度不易扩展</p>
<p>例如：1.如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和， 则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。2.如果文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，而这种方式效率是非常低的。</p>
<p>2.链表分配</p>
<p>为每个文件构造磁盘块链表，每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。这样的方法不会因为磁盘碎片而浪费存储空间。然而链表分配方案中，顺序访问读文件比较方便，但是随机访问却相当缓慢，无法直接访问。例如如果要获得块n，操作系统每一次都必须从头开始，并且要先读前面的n-1块。</p>
<p>3.采用内存中的表进行链表分配</p>
<p>取出每个磁盘块中的指针，把他们放在内存中的一个表中。它指<strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中</strong>，该表在整个<strong>磁盘仅设置一张</strong>，<strong>每个表项中存放链接指针，指向下一个数据块号</strong>。</p>
<p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为文件分配表（File Allocation Table，FAT）。</p>
<img src="/2023/05/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1.png" class="">

<img src="D:\myblog\hexoblog\source\_posts\文件系统\1.png" style="zoom:80%;" />

<p>由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。但也正是整个表都存放在内存中的关系，它的主要的缺点是不适用于<strong>大磁盘</strong>。</p>
<p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。</p>
<p>4.i节点</p>
<p>给每个文件赋予一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。相对于在内存中采用表的方式，这种机制有很大优势，即只有在文件打开的时候，i节点才会在内存中。如果每个i节点占有n个字节，最多有K个文件同时打开，那么为保留i节点的数组所占据的内存仅仅是kn个字节，只需要提前保留这么多空间即可。</p>
<p>如果每个i节点只能存储固定数量的磁盘地址，那么当一个文件所含的磁盘块的数目超过了i节点所能容纳的数目时，只要使i节点中的最后一个“磁盘地址”不指向数据块，而是指向一个包含额外磁盘块地址的快的地址。</p>
<img src="/2023/05/04/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2.jpg" class="">

<img src="D:\myblog\hexoblog\source\_posts\文件系统\2.jpg" alt="2"  />
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet?"></a>什么是Internet?</h1><h1 id="网络边缘与网络核心"><a href="#网络边缘与网络核心" class="headerlink" title="网络边缘与网络核心"></a>网络边缘与网络核心</h1>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>调度</title>
    <url>/2023/04/30/%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>调度是系统将<strong>计算机资源</strong>分配给进程。</p>
<p>在单道程序环境下，只有一个进程存在，计算机的所有资源由一个进程独占，没有资源竞争问题。然而在多道程序环境下，多个进程并发运行，各进程之间存在资源的相互<strong>竞争</strong>，特别是对处理器资源的竞争，从而影响到系统性能。</p>
<p>例题：1.在一个单CPU的计算机系统中，有两台外部设备R1、R2和三个进程P1、P2、P3。系统采用可剥夺式优先级的进程调度方案，且所有进程可以并行使用I&#x2F;O设备，三个进程的优先级、使用设备的先后顺序和占用设备时间如下表所示：</p>
<img src="/2023/04/30/%E8%B0%83%E5%BA%A6/1.jpg" class="">

<p><strong>对于不同的进程，优先级更高的进程会首先占用CPU。</strong></p>
<p>首先P1进程使用R2资源30ms，所以P1的前30ms注明为R2。与此同时P2使用R1资源20ms，P3同时申请使用CPU 40ms。当P3申请使用CPU时，没有其它进程申请使用CPU，所以P3顺利得到了CPU的使用权。但我们可以看到，当系统时间到20ms时，P3失去了CPU资源，这是为什么呢因为此时P2已经使用完R1，它开始申请使用CPU了，P2的优先级比P3高，所以系统从P3手中收回CPU的使用权，把CPU分配给P2使用。当系统时间到30ms时，系统又从P2手中收回了CPU的使用权，把CPU分配给了P1使用，因为系统中P1的优先级比P2高。</p>
<p>P1,P2,P3占用R1，R2，CPU图像如下：</p>
<img src="/2023/04/30/%E8%B0%83%E5%BA%A6/2.jpg" class="">

<p>从图可以看出P2在使用R1设备20ms后，要使用CPU30ms，但当其运行10ms后， P1要使用CPU，由于系统采用可剥夺方式调度，P1优先级高，所以将P2暂停，让P1先运行。同理，P3开始就使用CPU，但在运行20ms后，要让给高优先级的进程P2和 P1。P1从投入运行到完成需要80ms，而P2、P3由于等待资源，运行时间都延长为100ms。 CPU在90ms～100ms共10ms时间内没有利用，所以利用率为90&#x2F;100&#x3D;90%，同样计算得R2的利用率为70&#x2F;100&#x3D;70%，R1的利用率为60%。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>进程的调度</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2023/04/27/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前缀和、差分"><a href="#前缀和、差分" class="headerlink" title="前缀和、差分"></a>前缀和、差分</h1><p><strong><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">统计优美字数组</a></strong></p>
<h1 id="双指针扫描"><a href="#双指针扫描" class="headerlink" title="双指针扫描"></a>双指针扫描</h1><h1 id="哈希表、集合、映射"><a href="#哈希表、集合、映射" class="headerlink" title="哈希表、集合、映射"></a>哈希表、集合、映射</h1><p><strong>集合</strong></p>
<ul>
<li><p>文档</p>
</li>
<li><p>unordered_set<string>s;</p>
</li>
<li><p>insert,find,erase,clear等方法</p>
</li>
<li><p>mulitest</p>
</li>
</ul>
<p>映射</p>
<ul>
<li>文档</li>
<li>unordered_map&lt;string,int&gt;h;</li>
<li>h[key]&#x3D;value;</li>
<li>find(key),erase(key),clear 等方法</li>
<li>multimap</li>
</ul>
<p>实战题目：<br><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></p>
<p><a href="https://leetcode.cn/problems/walking-robot-simulation/">模拟行走机器人</a></p>
<p><a href="https://leetcode.cn/problems/group-anagrams/submissions/">字母异位词分组</a></p>
<p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/submissions/">串联所有单词的子串</a></p>
<p><a href="https://leetcode.cn/problems/lru-cache/">LRU缓存</a></p>
<h1 id="递归、分治、回溯算法"><a href="#递归、分治、回溯算法" class="headerlink" title="递归、分治、回溯算法"></a>递归、分治、回溯算法</h1>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2023/04/23/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> *message;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the child process. My PID is: %d. My PPID is: %d.\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the parent process. My PID is %d.\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子进程读取文件内容"><a href="#子进程读取文件内容" class="headerlink" title="子进程读取文件内容"></a>子进程读取文件内容</h3><p><strong>编写一个程序prog#1，要求</strong>：</p>
<p><strong>(a) 该程序带有一个参数，用以指定要操作的文本文件</strong></p>
<p><strong>(b) 把指定文本文件的内容显示在屏幕上。</strong></p>
<p><strong>(c) 程序末尾显示总共显示了上述文件的文本行数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 #include &lt;stdio.h&gt;</span><br><span class="line">2 #include &lt;stdlib.h&gt;</span><br><span class="line">3 #define MAX_LINE 1024</span><br><span class="line">4 int main(int argc, char* argv[]) &#123;</span><br><span class="line">5 FILE* fp;</span><br><span class="line">6 char line[MAX_LINE];</span><br><span class="line">7 int line_count = 0</span><br><span class="line">8 fp = fopen(&quot;ku.txt&quot;, &quot;r&quot;);</span><br><span class="line">9 if (fp == NULL) &#123;</span><br><span class="line">10 printf(&quot;文件不存在\n&quot;);</span><br><span class="line">11 return 0;</span><br><span class="line">12      &#125;   </span><br><span class="line">13 while (fgets(line, MAX_LINE, fp) != NULL) &#123;</span><br><span class="line">14 printf(&quot;%s&quot;, line); </span><br><span class="line">15 line_count++;</span><br><span class="line">16      &#125; </span><br><span class="line">17 fclose(fp); </span><br><span class="line">18 printf(&quot;文件共有 %d 行\n&quot;, line_count);</span><br><span class="line">19 return 0;</span><br><span class="line">20  &#125;</span><br><span class="line"> //此程序编写在shiyan01.c中                                       </span><br></pre></td></tr></table></figure>

<p><strong>编写一个主程序，该程序使用fork()来创建一个子进程，然后通过该子进程执行上述程序prog#1：</strong></p>
<p> <strong>(a) 使用exec()来执行；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">//该程序文件为shiyan01</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">5</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"> <span class="number">6</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 7 &#123;</span><br><span class="line"> <span class="number">8</span> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="number">9</span> pid=fork();</span><br><span class="line"><span class="number">10</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">11</span> execl(<span class="string">&quot;/home/healer/shiyan01&quot;</span>,<span class="string">&quot;shiyan01&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span> <span class="keyword">else</span> <span class="keyword">if</span>( pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">14</span> wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(b) 使用system()来执行；</strong></p>
<h3 id="把文件复制到另一个文件"><a href="#把文件复制到另一个文件" class="headerlink" title="把文件复制到另一个文件"></a>把文件复制到另一个文件</h3><p><strong>把文件b.c复制到a.c中</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="number">5</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="number">6</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">7</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 8 &#123;</span><br><span class="line"> <span class="number">9</span>     <span class="type">const</span> <span class="type">char</span>* pathName=<span class="string">&quot;a.c&quot;</span>;</span><br><span class="line"><span class="number">10</span>     <span class="type">int</span> in,out,flag;</span><br><span class="line"><span class="number">11</span>     <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="number">12</span>     in=open(<span class="string">&quot;b.c&quot;</span>,O_RDONLY,S_IRUSR);</span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span>(<span class="number">-1</span>==in)</span><br><span class="line"><span class="number">14</span>     &#123;</span><br><span class="line"><span class="number">15</span>         <span class="built_in">printf</span>(<span class="string">&quot; 打开文件b.c失败 !\n&quot;</span>);</span><br><span class="line"><span class="number">16</span>         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span>     out=creat(pathName,S_IWUSR);</span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span>(<span class="number">-1</span>==in)</span><br><span class="line"><span class="number">20</span>     &#123;</span><br><span class="line"><span class="number">21</span>         <span class="built_in">printf</span>(<span class="string">&quot;创建文件 %s 失败!\n&quot;</span>,pathName);</span><br><span class="line"><span class="number">22</span>         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">while</span>((flag=read(in,buffer,<span class="number">1024</span>))&gt;<span class="number">0</span>)</span><br><span class="line"><span class="number">25</span>     &#123;</span><br><span class="line"><span class="number">26</span>         write(out,buffer,flag);</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span>     close(in);</span><br><span class="line"><span class="number">29</span>     close(out);</span><br><span class="line"><span class="number">30</span>     <span class="built_in">printf</span>(<span class="string">&quot;复制文件b.c到%s 完毕!\n&quot;</span>,pathName);</span><br><span class="line"><span class="number">31</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">32</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>试设计程序利用<strong>管道</strong>完成如下进行通信：</p>
<p><strong>父进程通过管道向子进程发送一个字符串”PARENT PROCESS IS SENDING YOU A MESSAGE”，子进程收到信息后将该字符串转换为小写格式然后显示出来、并向父进程发送信息”child process got the message”，父进程收到信息后将该字符串转换为大写格式然后显示出来。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">5.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">6.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">7.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="number">8.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="number">9.</span>	<span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="number">10.</span>	</span><br><span class="line"><span class="number">11.</span>	<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">12.	&#123;</span><br><span class="line"><span class="number">13.</span>	 <span class="type">int</span> data_processed;</span><br><span class="line"><span class="number">14.</span>	 <span class="type">int</span> data_processed_sec;</span><br><span class="line"><span class="number">15.</span>	 <span class="type">int</span> file_pipes[<span class="number">2</span>];   <span class="comment">//子进程通过此管道写数据给父进程,文件描述符file_pipes[0]和file_pipes[1]分别构成管道的两端，往file_pipes[1]写入的数据可以从file_pipes[0]读出，并且file_pipes[1]一端只能进行写操作，file_pipes[0]一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。</span></span><br><span class="line"><span class="number">16.</span>	 <span class="type">int</span> file_pipes_sec[<span class="number">2</span>];<span class="comment">//父进程通过此管道写数据给子进程</span></span><br><span class="line"><span class="number">17.</span>	 <span class="type">const</span> <span class="type">char</span> dadINfo[] = <span class="string">&quot;PARENT PROCESS IS SENDING YOU A MESSAGE&quot;</span>;</span><br><span class="line"><span class="number">18.</span>	 <span class="type">const</span> <span class="type">char</span> sonINfo[] = <span class="string">&quot;child got the message&quot;</span>;</span><br><span class="line"><span class="number">19.</span>	 <span class="type">char</span> buffer[BUF_SIZE +<span class="number">1</span>];</span><br><span class="line"><span class="number">20.</span>	 <span class="type">char</span> buffer_sec[BUF_SIZE +<span class="number">1</span>];</span><br><span class="line"><span class="number">21.</span>	 </span><br><span class="line"><span class="number">22.</span>	    <span class="type">pid_t</span> fork_result;<span class="comment">//进程号</span></span><br><span class="line"><span class="number">23.</span>	 </span><br><span class="line"><span class="number">24.</span>	 <span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(buffer)); <span class="comment">//buffer初始化为0</span></span><br><span class="line"><span class="number">25.</span>	 </span><br><span class="line"><span class="number">26.</span>	 <span class="keyword">if</span>(pipe(file_pipes) == <span class="number">0</span> &amp;&amp; pipe(file_pipes_sec) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">27.</span>	  fork_result = fork();<span class="comment">//创建进程</span></span><br><span class="line"><span class="number">28.</span>	  <span class="keyword">if</span>(fork_result ==  - <span class="number">1</span>)&#123;<span class="comment">//进程创建失败</span></span><br><span class="line"><span class="number">29.</span>	   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fork failusre&quot;</span>);</span><br><span class="line"><span class="number">30.</span>	   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">31.</span>	  &#125;</span><br><span class="line"><span class="number">32.</span>	  <span class="keyword">if</span>(fork_result == <span class="number">0</span>)&#123;<span class="comment">//子进程</span></span><br><span class="line"><span class="number">33.</span>	   data_processed_sec = read(file_pipes_sec[<span class="number">0</span>],buffer_sec,BUF_SIZE);<span class="comment">//子进程读数据，存于buffer_sec中</span></span><br><span class="line"><span class="number">34.</span>	   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">35.</span>	   <span class="keyword">for</span>(;buffer_sec[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line"><span class="number">36.</span>	    <span class="keyword">if</span>(buffer_sec[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;buffer_sec[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line"><span class="number">37.</span>	      buffer_sec[i] += <span class="number">32</span>;</span><br><span class="line"><span class="number">38.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;%d - 子进程接收，转为小写显示:%s \n&quot;</span>,getpid(),buffer_sec);</span><br><span class="line"><span class="number">39.</span>	   data_processed = write(file_pipes[<span class="number">1</span>],sonINfo,<span class="built_in">strlen</span>(sonINfo));<span class="comment">//子进程写数据</span></span><br><span class="line"><span class="number">40.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;%d - 子进程写:child got the message\n&quot;</span>,getpid());</span><br><span class="line"><span class="number">41.</span>	   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">42.</span>	  &#125;</span><br><span class="line"><span class="number">43.</span>	  <span class="keyword">else</span>&#123;<span class="comment">//父进程</span></span><br><span class="line"><span class="number">44.</span>	   data_processed_sec = write(file_pipes_sec[<span class="number">1</span>],dadINfo,<span class="built_in">strlen</span>(dadINfo));<span class="comment">//父进程写数据</span></span><br><span class="line"><span class="number">45.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;%d - 父进程写：PARENT PROCESS IS SENDING YOU A MESSAGE%d \n&quot;</span>,getpid()); </span><br><span class="line"><span class="number">46.</span>	   data_processed = read(file_pipes[<span class="number">0</span>],buffer,BUF_SIZE);<span class="comment">//父进程读数据，数据存于buffer中</span></span><br><span class="line"><span class="number">47.</span>	   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">48.</span>	   <span class="keyword">for</span>(;buffer[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line"><span class="number">49.</span>	    <span class="keyword">if</span>(buffer[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;z&#x27;</span>) </span><br><span class="line"><span class="number">50.</span>	      buffer[i] -= <span class="number">32</span>;</span><br><span class="line"><span class="number">51.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;%d - 父进程接收，转为大写显示:%s \n&quot;</span>,getpid(),buffer);</span><br><span class="line"><span class="number">52.</span>	  &#125;</span><br><span class="line"><span class="number">53.</span>	 &#125;</span><br><span class="line"><span class="number">54.</span>	 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">55.</span>	&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/23/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.jpg" class="">

<h3 id="共享内存进行通信"><a href="#共享内存进行通信" class="headerlink" title="共享内存进行通信"></a>共享内存进行通信</h3><p>试设计程序利用<strong>共享内存</strong>完成如下进程通信： </p>
<p><strong>父进程创建一个共享内存段，然后由子进程将该共享内存附加到自己的地址空间中，并在该共享内存中写入如下信息：“俺是子进程，在给你发送信息！”。在等待子进程对共享内存的操作完成后，父进程将该共享内存附加到自己的地址空间中，并读出该共享内存的信息以及该共享内存段的其它信息（内存大小、建立该共享内存的进程ID、操作该共享内存段的进程ID）并一起显示出来。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">3.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">4.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="number">5.</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="number">6.</span>	</span><br><span class="line"><span class="number">7.</span>	<span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="number">8.</span>	<span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"><span class="number">9.</span>	</span><br><span class="line"><span class="number">10.</span>	</span><br><span class="line"><span class="number">11.</span>	<span class="meta">#<span class="keyword">define</span> TEXT_SZ 2048</span></span><br><span class="line"><span class="number">12.</span>	</span><br><span class="line"><span class="number">13.</span>	<span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span>&#123;</span></span><br><span class="line"><span class="number">14.</span>	 <span class="type">int</span> written;<span class="comment">//作为一个标志，非0：表示可读，0表示可写</span></span><br><span class="line"><span class="number">15.</span>	 <span class="type">char</span> text[TEXT_SZ];<span class="comment">//记录写入和读取的文本</span></span><br><span class="line"><span class="number">16.</span>	&#125;;</span><br><span class="line"><span class="number">17.</span>	</span><br><span class="line"><span class="number">18.</span>	 <span class="type">pid_t</span> son;</span><br><span class="line"><span class="number">19.</span>	<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">20.	&#123;</span><br><span class="line"><span class="number">21.</span>	</span><br><span class="line"><span class="number">22.</span>	    <span class="type">pid_t</span> pid;<span class="comment">//进程号</span></span><br><span class="line"><span class="number">23.</span>	 <span class="type">int</span> running = <span class="number">1</span>;<span class="comment">//程序是否继续运行的标志</span></span><br><span class="line"><span class="number">24.</span>	 <span class="type">void</span> *shm = <span class="literal">NULL</span>;<span class="comment">//分配的共享内存的原始首地址</span></span><br><span class="line"><span class="number">25.</span>	 <span class="type">char</span> buffer[BUF_SIZE + <span class="number">1</span>];<span class="comment">//用于保存输入的文本</span></span><br><span class="line"><span class="number">26.</span>	 <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared</span>;</span><span class="comment">//指向shm</span></span><br><span class="line"><span class="number">27.</span>	 <span class="type">int</span> shmid;<span class="comment">//共享内存标识符</span></span><br><span class="line"><span class="number">28.</span>	</span><br><span class="line"><span class="number">29.</span>	 <span class="comment">//创建共享内存</span></span><br><span class="line"><span class="number">30.</span>	 shmid = shmget((<span class="type">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_use_st), <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line"><span class="number">31.</span>	 </span><br><span class="line"><span class="number">32.</span>	 <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line"><span class="number">33.</span>	 &#123;</span><br><span class="line"><span class="number">34.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmget failed\n&quot;</span>);</span><br><span class="line"><span class="number">35.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">36.</span>	 &#125;</span><br><span class="line"><span class="number">37.</span>	 </span><br><span class="line"><span class="number">38.</span>	    <span class="comment">//创建子进程</span></span><br><span class="line"><span class="number">39.</span>	    pid = fork();</span><br><span class="line"><span class="number">40.</span>	 </span><br><span class="line"><span class="number">41.</span>	    <span class="keyword">if</span> ( <span class="number">0</span> &gt; pid )</span><br><span class="line"><span class="number">42.</span>	    &#123;</span><br><span class="line"><span class="number">43.</span>	        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="number">44.</span>	        shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">45.</span>	        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">46.</span>	    &#125;</span><br><span class="line"><span class="number">47.</span>	 </span><br><span class="line"><span class="number">48.</span>	    <span class="keyword">else</span> <span class="keyword">if</span> (  pid &gt; <span class="number">0</span> )</span><br><span class="line"><span class="number">49.</span>	    &#123;</span><br><span class="line"><span class="number">50.</span>	 <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line"><span class="number">51.</span>	 shm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">52.</span>	 <span class="keyword">if</span>(shm == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line"><span class="number">53.</span>	 &#123;</span><br><span class="line"><span class="number">54.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmat failed\n&quot;</span>);</span><br><span class="line"><span class="number">55.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">56.</span>	 &#125;</span><br><span class="line"><span class="number">57.</span>	 <span class="built_in">printf</span>(<span class="string">&quot;\n当前父进程内存地址：%X进程号：%d\n&quot;</span>, (<span class="type">int</span>)shm,getpid());</span><br><span class="line"><span class="number">58.</span>	 <span class="comment">//设置共享内存</span></span><br><span class="line"><span class="number">59.</span>	 shared = (<span class="keyword">struct</span> shared_use_st*)shm;</span><br><span class="line"><span class="number">60.</span>	 shared-&gt;written = <span class="number">0</span>;</span><br><span class="line"><span class="number">61.</span>	</span><br><span class="line"><span class="number">62.</span>	 <span class="keyword">while</span>(running)<span class="comment">//读取共享内存中的数据</span></span><br><span class="line"><span class="number">63.</span>	 &#123;</span><br><span class="line"><span class="number">64.</span>	  </span><br><span class="line"><span class="number">65.</span>	  <span class="comment">//没有进程向共享内存定数据有数据可读取</span></span><br><span class="line"><span class="number">66.</span>	  <span class="keyword">if</span>(shared-&gt;written != <span class="number">0</span>)</span><br><span class="line"><span class="number">67.</span>	  &#123;</span><br><span class="line"><span class="number">68.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;父进程读取共享内存: %s\n&quot;</span>, shared-&gt;text);</span><br><span class="line"><span class="number">69.</span>	   sleep(rand() % <span class="number">3</span>);</span><br><span class="line"><span class="number">70.</span>	   <span class="comment">//读取完数据，设置written使共享内存段可写</span></span><br><span class="line"><span class="number">71.</span>	   shared-&gt;written = <span class="number">0</span>;</span><br><span class="line"><span class="number">72.</span>	   <span class="comment">//输入了end，退出循环（程序）</span></span><br><span class="line"><span class="number">73.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;建立共享内存的进程号为：%d,内存大小为%d\n&quot;</span>,getpid(),SHM_SIZE);</span><br><span class="line"><span class="number">74.</span>	   <span class="keyword">if</span>(<span class="built_in">strncmp</span>(shared-&gt;text, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">75.</span>	    running = <span class="number">0</span>;</span><br><span class="line"><span class="number">76.</span>	  &#125;</span><br><span class="line"><span class="number">77.</span>	  <span class="keyword">else</span><span class="comment">//有其他进程在写数据，不能读取数据</span></span><br><span class="line"><span class="number">78.</span>	   sleep(<span class="number">1</span>);</span><br><span class="line"><span class="number">79.</span>	 &#125;</span><br><span class="line"><span class="number">80.</span>	 <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line"><span class="number">81.</span>	 <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line"><span class="number">82.</span>	 &#123;</span><br><span class="line"><span class="number">83.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmdt failed\n&quot;</span>);</span><br><span class="line"><span class="number">84.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">85.</span>	 &#125;</span><br><span class="line"><span class="number">86.</span>	 <span class="comment">//删除共享内存</span></span><br><span class="line"><span class="number">87.</span>	 <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line"><span class="number">88.</span>	 &#123;</span><br><span class="line"><span class="number">89.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmctl(IPC_RMID) failed\n&quot;</span>);</span><br><span class="line"><span class="number">90.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">91.</span>	 &#125;</span><br><span class="line"><span class="number">92.</span>	 <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="number">93.</span>	</span><br><span class="line"><span class="number">94.</span>	    &#125;</span><br><span class="line"><span class="number">95.</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">96.</span>	    &#123;</span><br><span class="line"><span class="number">97.</span>	     <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line"><span class="number">98.</span>	 shm = shmat(shmid, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">99.</span>	 <span class="keyword">if</span>(shm == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line"><span class="number">100.</span>	 &#123;</span><br><span class="line"><span class="number">101.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmat failed\n&quot;</span>);</span><br><span class="line"><span class="number">102.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">103.</span>	 &#125;</span><br><span class="line"><span class="number">104.</span>	  </span><br><span class="line"><span class="number">105.</span>	 <span class="built_in">printf</span>(<span class="string">&quot;当前子进程内存地址：%X进程号：%d\n&quot;</span>, (<span class="type">int</span>)shm,getpid());</span><br><span class="line"><span class="number">106.</span>	 son = getpid();</span><br><span class="line"><span class="number">107.</span>	 <span class="comment">//设置共享内存</span></span><br><span class="line"><span class="number">108.</span>	 shared = (<span class="keyword">struct</span> shared_use_st*)shm;</span><br><span class="line"><span class="number">109.</span>	   </span><br><span class="line"><span class="number">110.</span>	 <span class="keyword">while</span>(running)<span class="comment">//向共享内存中写数据</span></span><br><span class="line"><span class="number">111.</span>	 &#123;</span><br><span class="line"><span class="number">112.</span>	  <span class="comment">//数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本</span></span><br><span class="line"><span class="number">113.</span>	  <span class="keyword">while</span>(shared-&gt;written == <span class="number">1</span>)</span><br><span class="line"><span class="number">114.</span>	  &#123;</span><br><span class="line"><span class="number">115.</span>	   sleep(<span class="number">1</span>);</span><br><span class="line"><span class="number">116.</span>	   <span class="built_in">printf</span>(<span class="string">&quot;Waiting...\n&quot;</span>);</span><br><span class="line"><span class="number">117.</span>	  &#125;</span><br><span class="line"><span class="number">118.</span>	  <span class="comment">//向共享内存中写入数据</span></span><br><span class="line"><span class="number">119.</span>	  <span class="built_in">printf</span>(<span class="string">&quot;子进程向共享内存写入: &quot;</span>);</span><br><span class="line"><span class="number">120.</span>	  fgets(buffer, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="number">121.</span>	  <span class="built_in">strncpy</span>(shared-&gt;text, buffer, TEXT_SZ);</span><br><span class="line"><span class="number">122.</span>	  <span class="comment">//写完数据，设置written使共享内存段可读</span></span><br><span class="line"><span class="number">123.</span>	  shared-&gt;written = <span class="number">1</span>;</span><br><span class="line"><span class="number">124.</span>	  <span class="comment">//输入了end，退出循环（程序）</span></span><br><span class="line"><span class="number">125.</span>	    <span class="built_in">printf</span>(<span class="string">&quot;操作共享内存的进程号为%d&quot;</span>,getpid());</span><br><span class="line"><span class="number">126.</span>	  <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">127.</span>	   running = <span class="number">0</span>;</span><br><span class="line"><span class="number">128.</span>	 &#125;</span><br><span class="line"><span class="number">129.</span>	 <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line"><span class="number">130.</span>	 <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line"><span class="number">131.</span>	 &#123;</span><br><span class="line"><span class="number">132.</span>	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmdt failed\n&quot;</span>);</span><br><span class="line"><span class="number">133.</span>	  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="number">134.</span>	 &#125;</span><br><span class="line"><span class="number">135.</span>	 sleep(<span class="number">2</span>);</span><br><span class="line"><span class="number">136.</span>	 <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="number">137.</span>	    &#125;</span><br><span class="line"><span class="number">138.</span>	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">139.</span>	&#125;</span><br><span class="line"><span class="number">140.</span>	 </span><br><span class="line"><span class="number">141.</span>	 </span><br><span class="line"></span><br></pre></td></tr></table></figure>













































<hr>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>进程与线程</tag>
      </tags>
  </entry>
</search>
